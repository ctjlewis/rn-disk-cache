"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("path");function a(t){return t&&"object"==typeof t&&"default"in t?t:{"default":t}}var e=a(require("react-native-fs"));const{DocumentDirectoryPath:i,mkdir:n,readDir:s,readFile:c,unlink:r,writeFile:o}=e.default,l=t.join(i,"__caches__");class h{name;maxAge;silent;cachePath;lockFile;constructor(a,e,i=!1){this.name=a,this.maxAge=e,this.silent=i,this.cachePath=t.join(l,this.name),this.lockFile=t.join(this.cachePath,".lock")}log(...t){this.silent||console.log(`CACHE [${this.name}]`,...t)}async lock(){return this.log("Locking cache store."),await e.default.writeFile(this.lockFile,"")}async unlock(){return this.log("Unlocking cache store."),await e.default.unlink(this.lockFile)}async isLocked(){return await e.default.exists(this.lockFile)}async waitForUnlock(){return this.log("Waiting for unlock..."),await new Promise((async t=>{const a=async()=>{await this.isLocked()?setTimeout(a,100*Math.random()):t(!0)};await a()}))}async getCaches(){return await n(this.cachePath),(await s(this.cachePath)).filter((t=>NaN!==Number(t.name))).sort(((t,a)=>Number(a.name)-Number(t.name)))}async getValidCache(){this.log("Reading most recent cache value.");const t=(await this.getCaches())[0];if(!t)return this.log("No caches found."),null;const a=Number(t.name),e=(Date.now()-a)/1e3,i=e>=this.maxAge;return this.log(`Cache found. Age: ${e} sec`),i?null:t}async clean(t){this.log(`Deleting ${t?"all":"old"} caches.`);const a=await this.getCaches(),e=t?a:a.slice(1);await Promise.all(e.map((async t=>await r(t.path))))}async read(){const t=await this.getValidCache();if(t){this.log("Valid cache found.");const a=await c(t.path);return{value:JSON.parse(a)}}return null}async write(a){const e=await this.read();if(e)return this.log("Valid cache found while trying to write. Using that instead."),e;{await this.waitForUnlock(),await this.lock(),await this.clean(!1),this.log("Writing new cache value.");const e=t.join(this.cachePath,`${Date.now()}`),i=JSON.stringify(a);return await o(e,i),await this.unlock(),{value:a}}}async poll(t,...a){const e=Date.now();try{const i=await this.read();if(i){const{value:t}=i;return t}{const{value:e}=await this.write(await t(...a));return e}}catch(t){throw this.log("Unrecoverable error. Files may be corrupted. Deleting all caches.",t),await this.clean(!0),new Error(`Error: ${t}`)}finally{this.log(`Finished in ${Date.now()-e}ms`)}}}exports.fromDiskCache=async({name:t,poll:a,maxAge:e=3600,silent:i=!1},...n)=>{const s=new h(t,e,i);try{return await s.poll(a,...n)}catch(t){throw console.trace({error:t}),new Error("Error refreshing cache")}};
//# sourceMappingURL=rn-disk-cache.production.min.cjs.map
