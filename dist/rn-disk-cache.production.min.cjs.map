{"version":3,"file":"rn-disk-cache.production.min.cjs","sources":["../src/CacheStore.ts","../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n * This file uses a class, which is a highly unpopular pattern nowadays, but was\n * necessary to avoid argument juggling between functions, and overall easier\n * state management.\n */\n\nimport { join } from 'path';\nimport fs from 'react-native-fs';\n\nconst {\n  DocumentDirectoryPath,\n  mkdir,\n  readDir,\n  readFile,\n  unlink,\n  writeFile,\n} = fs;\n\n/**\n * The directory where caches will be stored.\n */\nconst CACHE_DIR = join(DocumentDirectoryPath, '__caches__');\n\nexport class CacheStore<T> {\n  /**\n   * The path to this cache at ${CACHE_DIR}/{name}.\n   */\n  private cachePath: string;\n  /**\n   * Set the cache directory for this store.\n   */\n  constructor(\n    private name: string,\n    private maxAge: number,\n    private silent = false\n  ) {\n    this.cachePath = join(CACHE_DIR, this.name);\n  }\n  /**\n   * Try to read a non-stale cache, and if one doesn't exist, load a new one,\n   * cache it, and return it.\n   */\n   public async refresh(\n    fn: (...args: any[]) => T | Promise<T>,\n    ...args: any[]\n  ) {\n    /**\n     * The time the function started executing.\n     */\n    const startTime = Date.now();\n    try {\n      const nonStaleCache = await this.read();\n      if (nonStaleCache) {\n        const { value } = nonStaleCache;\n        return value;\n      } else {\n        const { value } = await this.write(await fn(...args));\n        return value;\n      }\n    } catch (error) {\n      this.log(\n        `Unrecoverable error. Files may be corrupted. Deleting all caches.`,\n        error\n      );\n      await this.clean(true);\n      throw new Error(`Error: ${error}`);\n    } finally {\n      this.log(`Finished in ${Date.now() - startTime}ms`);\n    }\n  }\n  /**\n   * Log messages and include the name of the cache.\n   */\n   private log(...msgs: any[]) {\n    if (!this.silent) {\n      console.log(`CACHE [${this.name}]`, ...msgs);\n    }\n  }\n  /**\n   * Ensure the cachePath exists, read any caches inside of it, and store it on\n   * `this.caches`.\n   */\n  private async update() {\n    /**\n     * Make sure this cache directory exists.\n     */\n    await mkdir(this.cachePath);\n    /**\n     * Find available caches and sort them by increasing age.\n     */\n    const cachesInDir = await readDir(this.cachePath);\n    const sortedCaches = cachesInDir.sort(\n      (a, b) => Number(b.name) - Number(a.name)\n    );\n\n    return sortedCaches;\n  }\n  /**\n   * Delete all caches except the most recent, unless `all: true` is\n   * specified, in which case all caches will be deleted.\n   */\n  private async clean(all: boolean) {\n    this.log(`Deleting ${all ? 'all' : 'old'} caches.`);\n\n    const caches = await this.update();\n    const cachesToDelete = all ? caches : caches.slice(1);\n    await Promise.all(\n      cachesToDelete.map(\n        async (cache) => await unlink(cache.path)\n      )\n    );\n  }\n  /**\n   * Try to read a non-stale cache value. If one is not found, return `null`.\n   */\n  private async read() {\n    this.log('Reading most recent cache value.');\n    const caches = await this.update();\n    const mostRecentCache = caches[0];\n\n    if (!mostRecentCache) {\n      this.log('No caches found.');\n      return null;\n    }\n\n    const mostRecentCacheTimestamp = Number(mostRecentCache.name);\n    const mostRecentCacheAge = (Date.now() - mostRecentCacheTimestamp) / 1000;\n    const mostRecentCacheIsStale = mostRecentCacheAge >= this.maxAge;\n\n    this.log(`Cache found. Age: ${mostRecentCacheAge}s`);\n\n    if (mostRecentCacheIsStale) {\n      this.log('Cache is stale.');\n      return null;\n    } else {\n      this.log('Cache is not stale.');\n      const fileContents = await readFile(mostRecentCache.path);\n      const value: T = JSON.parse(fileContents);\n      /**\n       * Return as an object to prevent issues if the cached value happened to be\n       * `null`.\n       */\n      return { value };\n    }\n  };\n  /**\n   * Write the new value to the cache.\n   */\n  private async write(value: T) {\n    this.log('Writing new cache value.');\n    const file = join(this.cachePath, `${Date.now()}`);\n    /**\n     * Delete all except the most recent cache.\n     */\n    await this.clean(false);\n    /**\n     * Write new cache and return.\n     */\n    const serialized = JSON.stringify(value);\n    await writeFile(file, serialized);\n\n    return { value };\n  };\n}","import { CacheStore } from './CacheStore';\n\ninterface FromDiskCacheArgs<T>{\n  name: string;\n  refresh: (...args: any[]) => T | Promise<T>;\n  maxAge?: number;\n  silent?: boolean;\n}\n\n/**\n * Cache an object on the filesystem, given a `name`, `refresh` (can be async),\n * and `maxAge` (defaults to 1hr).\n *\n * Pass `silent: true` to disable logs.\n */\nexport const fromDiskCache = async <T>(\n  {\n    name,\n    refresh,\n    maxAge = 60 * 60,\n    silent = false,\n  }: FromDiskCacheArgs<T>,\n  ...args: any[]\n): Promise<T> => {\n  /**\n   * Initialize a reference to this cache store.\n   */\n  const cacheStore = new CacheStore<T>(name, maxAge, silent);\n  /**\n   * Read a cached version of the value, or write a new one if it doesn't exist\n   * and return that.\n   */\n  try {\n    return await cacheStore.refresh(refresh, ...args);\n  } catch (error) {\n    throw new Error(`Error refreshing cache: ${error}`);\n  }\n};"],"names":["DocumentDirectoryPath","mkdir","readDir","readFile","unlink","writeFile","fs","CACHE_DIR","join","CacheStore","name","maxAge","silent","cachePath","constructor","this","refresh","fn","args","startTime","Date","now","nonStaleCache","read","value","write","error","log","clean","Error","msgs","console","update","sort","a","b","Number","all","caches","cachesToDelete","slice","Promise","map","async","cache","path","mostRecentCache","mostRecentCacheTimestamp","mostRecentCacheAge","mostRecentCacheIsStale","fileContents","JSON","parse","file","serialized","stringify","cacheStore"],"mappings":"wMAUA,MAAMA,sBACJA,EAAqBC,MACrBA,EAAKC,QACLA,EAAOC,SACPA,EAAQC,OACRA,EAAMC,UACNA,GACEC,UAKEC,EAAYC,OAAKR,EAAuB,oBAEjCS,EASDC,KACAC,OACAC,OAPFC,UAIRC,YACUJ,EACAC,EACAC,GAAS,GAFTG,UAAAL,EACAK,YAAAJ,EACAI,YAAAH,EAERG,KAAKF,UAAYL,OAAKD,EAAWQ,KAAKL,MAMhCM,cACNC,KACGC,GAKH,MAAMC,EAAYC,KAAKC,MACvB,IACE,MAAMC,QAAsBP,KAAKQ,OACjC,GAAID,EAAe,CACjB,MAAME,MAAEA,GAAUF,EAClB,OAAOE,EACF,CACL,MAAMA,MAAEA,SAAgBT,KAAKU,YAAYR,KAAMC,IAC/C,OAAOM,GAET,MAAOE,GAMP,MALAX,KAAKY,IACH,oEACAD,SAEIX,KAAKa,OAAM,GACX,IAAIC,MAAM,UAAUH,aAE1BX,KAAKY,IAAI,eAAeP,KAAKC,MAAQF,QAMhCQ,OAAOG,GACTf,KAAKH,QACRmB,QAAQJ,IAAI,UAAUZ,KAAKL,WAAYoB,GAOnCE,eAaN,aATM/B,EAAMc,KAAKF,kBAISX,EAAQa,KAAKF,YACNoB,MAC/B,CAACC,EAAGC,IAAMC,OAAOD,EAAEzB,MAAQ0B,OAAOF,EAAExB,QAShCkB,YAAYS,GAClBtB,KAAKY,IAAI,YAAYU,EAAM,MAAQ,iBAEnC,MAAMC,QAAevB,KAAKiB,SACpBO,EAAiBF,EAAMC,EAASA,EAAOE,MAAM,SAC7CC,QAAQJ,IACZE,EAAeG,KACbC,MAAOC,SAAgBxC,EAAOwC,EAAMC,SAOlCtB,aACNR,KAAKY,IAAI,oCACT,MACMmB,SADe/B,KAAKiB,UACK,GAE/B,IAAKc,EAEH,OADA/B,KAAKY,IAAI,oBACF,KAGT,MAAMoB,EAA2BX,OAAOU,EAAgBpC,MAClDsC,GAAsB5B,KAAKC,MAAQ0B,GAA4B,IAC/DE,EAAyBD,GAAsBjC,KAAKJ,OAI1D,GAFAI,KAAKY,IAAI,qBAAqBqB,MAE1BC,EAEF,OADAlC,KAAKY,IAAI,mBACF,KACF,CACLZ,KAAKY,IAAI,uBACT,MAAMuB,QAAqB/C,EAAS2C,EAAgBD,MAMpD,MAAO,CAAErB,MALQ2B,KAAKC,MAAMF,KAWxBzB,YAAYD,GAClBT,KAAKY,IAAI,4BACT,MAAM0B,EAAO7C,OAAKO,KAAKF,UAAW,GAAGO,KAAKC,eAIpCN,KAAKa,OAAM,GAIjB,MAAM0B,EAAaH,KAAKI,UAAU/B,GAGlC,aAFMnB,EAAUgD,EAAMC,GAEf,CAAE9B,MAAAA,0BCnJgBmB,OAEzBjC,KAAAA,EACAM,QAAAA,EACAL,OAAAA,EAAS,KACTC,OAAAA,GAAS,MAERM,KAKH,MAAMsC,EAAa,IAAI/C,EAAcC,EAAMC,EAAQC,GAKnD,IACE,aAAa4C,EAAWxC,QAAQA,KAAYE,GAC5C,MAAOQ,GACP,MAAM,IAAIG,MAAM,2BAA2BH"}