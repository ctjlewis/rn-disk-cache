{"version":3,"file":"rn-disk-cache.development.cjs","sources":["../src/CacheStore.ts","../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n * This file uses a class, which is a highly unpopular pattern nowadays, but was\n * necessary to avoid argument juggling between functions.\n */\n\nimport { join } from 'path';\nimport fs from 'react-native-fs';\n\nconst {\n  DocumentDirectoryPath,\n  mkdir,\n  readDir,\n  readFile,\n  unlink,\n  writeFile,\n} = fs;\n\ntype Cache = fs.ReadDirItem;\n\n/**\n * The directory where caches will be stored.\n */\nconst CACHE_DIR = join(DocumentDirectoryPath, '__caches__');\n\nexport class CacheStore<T> {\n  /**\n   * The path to this cache at ${CACHE_DIR}/{name}.\n   */\n  private cachePath: string;\n  /**\n   * Set the cache directory for this store.\n   */\n  constructor(public name: string) {\n    this.cachePath = join(CACHE_DIR, this.name);\n  }\n  /**\n   * List all caches in this store.\n   */\n  private getCaches = async (): Promise<Cache[]> => {\n    /**\n     * Make sure this cache directory exists.\n     */\n    await mkdir(this.cachePath);\n    /**\n     * Find available caches and sort them by increasing age.\n     */\n    const cacheResults = await readDir(this.cachePath);\n    return cacheResults.sort(\n      (a, b) => Number(b.name) - Number(a.name)\n    );\n  }\n  /**\n   * Get the most recent cache \n   */\n  public getMostRecentCache = async (): Promise<Cache> => {\n    const caches = await this.getCaches();\n    return caches[0];\n  };\n  /**\n   * Read the most recent cached value.\n   */\n  public read = async () => {\n    console.log('Reading most recent cache value.');\n    const mostRecentCache = await this.getMostRecentCache();\n    const fileContents = await readFile(mostRecentCache.name);\n    const cacheValue = JSON.parse(fileContents);\n    return cacheValue;\n  };\n  /**\n   * Write the new value to the cache.\n   */\n  public write = async (cacheValue: T) => {\n    console.log('Writing new cache value.');\n    const cacheFile = join(this.cachePath, `${Date.now()}`);\n    /**\n     * Delete all except the most recent cache.\n     */\n    await this.deleteCaches(false);\n    /**\n     * Write new cache and return.\n     */\n    const serialized = JSON.stringify(cacheValue);\n    await writeFile(cacheFile, serialized);\n    return cacheValue;\n  };\n  /**\n   * Delete all caches except the most recent, unless `clean: true` is\n   * specified, in which case all caches will be deleted.\n   */\n  public deleteCaches = async (clean: boolean) => {\n    console.log(`Deleting ${clean ? 'all' : 'old'} caches.`);\n    const caches = await this.getCaches();\n    const cachesToDelete = clean ? caches : caches.slice(1);\n    await Promise.all(\n      cachesToDelete.map(\n        async (cache) => await unlink(cache.path)\n      )\n    );\n  }\n}","import { CacheStore } from './CacheStore';\n\n/**\n * Cache an object on the filesystem for a given amount of time.\n *\n * @param name A tag that will be used to name the temp directory.\n * @param fn A function that returns, or Promise that resolves to, the object to\n * cache.\n * @param seconds The number of seconds to cache the object for.\n * @param args Passed to the async function via `await fn(...args)`.\n */\nexport const fromDiskCache = async <T>(\n  name: string,\n  fn: () => T | Promise<T>,\n  seconds = 60 * 60,\n  ...args: []\n): Promise<T> => {\n  /**\n   * The time the function started executing.\n   */\n  const startTime = Date.now();\n  const cacheStore = new CacheStore<T>(name);\n  /**\n   * Await and write the new value.\n   */\n  const updateStore = async () => {\n    const newValue = await fn(...args);\n    return await cacheStore.write(newValue);\n  };\n  /**\n   * Try to read from available caches. Clear all caches if an error is\n   * encountered.\n   */\n  try {\n    const mostRecentCache = await cacheStore.getMostRecentCache();\n    const mostRecentTimestamp = !mostRecentCache\n      ? 0\n      : Number(mostRecentCache.name);\n    /**\n     * If no caches were found, write a new value.\n     */\n    if (!mostRecentCache) {\n      console.log('No caches found.');\n      return await updateStore();\n    }\n    /**\n     * If caches were found, determine if they're stale.\n     */\n    const secondsOld = (Date.now() - mostRecentTimestamp) / 1000;\n    const cacheIsStale = secondsOld >= seconds;\n    console.log(`Caches found for store: ${name}`, { cacheIsStale, secondsOld });\n    /**\n     * If the cache is not stale, read the value and return it.\n     */\n    if (cacheIsStale) {\n      console.log('Cache is stale.');\n      return await updateStore();\n    } else {\n      console.log('Cache is not stale.');\n      return await cacheStore.read();\n    }\n  } catch (error) {\n    console.log(\n      `Unrecoverable error. Files may be corrupted. Deleting all caches.`\n    );\n    await cacheStore.deleteCaches(true);\n    throw new Error(`Error: ${error}`);\n  } finally {\n    console.log(`Finished in ${Date.now() - startTime}ms`);\n  }\n};\n"],"names":["fs","join"],"mappings":"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"}