{"version":3,"file":"rn-disk-cache.development.cjs","sources":["../src/CacheStore.ts","../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n * This file uses a class, which is a highly unpopular pattern nowadays, but was\n * necessary to avoid argument juggling between functions, and overall easier\n * state management.\n */\n\nimport { join } from 'path';\nimport fs from 'react-native-fs';\n\nconst {\n  DocumentDirectoryPath,\n  mkdir,\n  readDir,\n  readFile,\n  unlink,\n  writeFile,\n} = fs;\n\n/**\n * The directory where caches will be stored.\n */\nconst CACHE_DIR = join(DocumentDirectoryPath, '__caches__');\n\nexport class CacheStore<T> {\n  /**\n   * The path to this cache at ${CACHE_DIR}/{name}.\n   */\n  private cachePath: string;\n  /**\n   *  The path to the lockfile for this store.\n   */\n  private lockFile: string;\n  /**\n   * Set the cache directory for this store.\n   */\n  constructor(\n    private name: string,\n    private maxAge: number,\n    private silent = false\n  ) {\n    this.cachePath = join(CACHE_DIR, this.name);\n    this.lockFile = join(this.cachePath, '.lock');\n  }\n  /**\n   * Log messages and include the name of the cache.\n   */\n  private log(...msgs: any[]) {\n    if (!this.silent) {\n      console.log(`CACHE [${this.name}]`, ...msgs);\n    }\n  }\n  /**\n   * Write the lockfile.\n   */\n  private async lock() {\n    this.log('Locking cache store.');\n    return await fs.writeFile(this.lockFile, '');\n  }\n  /**\n   * Delete the lockfile.\n   */\n  private async unlock() {\n    this.log('Unlocking cache store.')\n    return await fs.unlink(this.lockFile);\n  }\n  /**\n   * Check if the lockfile exists.\n   */\n  private async isLocked() {\n    return await fs.exists(this.lockFile);\n  }\n  /**\n   * Returns a Promise that resolves when the lockfile is deleted.\n   */\n  private async waitForUnlock() {\n    this.log('Waiting for unlock...');\n    return await new Promise((resolve) => {\n      const checkForUnlock = async () => {\n        if (!(await this.isLocked())) {\n          resolve(true);\n        } else {\n          setTimeout(checkForUnlock, 100 * Math.random());\n        }\n      }\n    });\n  }\n  /**\n   * Ensure the cachePath exists, and return any caches inside of it, sorted by\n   * increasing age.\n   */\n  private async getCaches() {\n    /**\n     * Make sure this cache directory exists.\n     */\n    await mkdir(this.cachePath);\n    /**\n     * Find available caches and sort them by increasing age.\n     */\n    const cachesInDir = await readDir(this.cachePath);\n    const sortedCaches =\n      cachesInDir\n        .filter((f) => Number(f.name) !== NaN)\n        .sort((a, b) => Number(b.name) - Number(a.name));\n\n    return sortedCaches;\n  }\n  /**\n   * Return the most recent valid cache where `age < maxAge`, else `null`.\n   */\n  private async getValidCache() {\n    this.log('Reading most recent cache value.');\n\n    const caches = await this.getCaches();\n    const mostRecentCache = caches[0];\n\n    if (!mostRecentCache) {\n      this.log('No caches found.');\n      return null;\n    }\n\n    const mostRecentCacheTimestamp = Number(mostRecentCache.name);\n    const mostRecentCacheAge = (Date.now() - mostRecentCacheTimestamp) / 1000;\n    const mostRecentCacheIsStale = mostRecentCacheAge >= this.maxAge;\n\n    this.log(`Cache found. Age: ${mostRecentCacheAge} sec`);\n\n    if (!mostRecentCacheIsStale) {\n      return mostRecentCache;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Delete all caches except the most recent, unless `all: true` is\n   * specified, in which case all caches will be deleted.\n   */\n   private async clean(all: boolean) {\n    this.log(`Deleting ${all ? 'all' : 'old'} caches.`);\n\n    const caches = await this.getCaches();\n    const cachesToDelete = all ? caches : caches.slice(1);\n    await Promise.all(\n      cachesToDelete.map(\n        async (cache) => await unlink(cache.path)\n      )\n    );\n  }\n  /**\n   * Try to read the most recent valid cache. Return `null` if none found.\n   */\n  private async read() {\n    const cache = await this.getValidCache();\n    if (cache) {\n      this.log('Valid cache found.');\n      const fileContents = await readFile(cache.path);\n      const value: T = JSON.parse(fileContents);\n      /**\n       * Return as an object to prevent issues if the cached value happened to be\n       * `null`.\n       */\n      return { value };\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Write the new value to the cache.\n   */\n  private async write(value: T) {\n    /**\n     * If there's a valid cache, bail out and return that.\n     */\n    const cacheValue = await this.read();\n    if (cacheValue) {\n      this.log('Valid cache found while trying to write. Using that instead.');\n      return cacheValue;\n    } else {\n      /**\n       * Wait for unlock, then resume.\n       */\n      await this.waitForUnlock();\n      this.log('Writing new cache value.');\n\n      /**\n       * Delete all except the most recent cache and set the lockfile.\n       */\n      await this.lock();\n      await this.clean(false);\n      /**\n       * Write new cache and unlock the directory.\n       */\n      const file = join(this.cachePath, `${Date.now()}`);\n      const serialized = JSON.stringify(value);\n      await writeFile(file, serialized);\n      await this.unlock();\n\n      return { value };\n    }\n  }\n  /**\n   * Try to read a non-stale cache, and if one doesn't exist, load a new one,\n   * cache it, and return it.\n   *\n   * This is delayed by a random amount of time, up to 100ms, to support\n   * concurrency.\n   */\n  public async poll(\n    fn: (...args: any[]) => T | Promise<T>,\n    ...args: any[]\n  ) {\n    /**\n     * The time the function started executing.\n     */\n    const startTime = Date.now();\n    try {\n      const cacheValue = await this.read();\n      if (cacheValue) {\n        const { value } = cacheValue;\n        return value;\n      } else {\n        const { value } = await this.write(await fn(...args));\n        return value;\n      }\n    } catch (error) {\n      this.log(\n        `Unrecoverable error. Files may be corrupted. Deleting all caches.`,\n        error\n      );\n\n      await this.clean(true);\n      throw new Error(`Error: ${error}`);\n    } finally {\n      this.log(`Finished in ${Date.now() - startTime}ms`);\n    }\n  }\n}","import { CacheStore } from './CacheStore';\n\ninterface FromDiskCacheArgs<T>{\n  name: string;\n  poll: (...args: any[]) => T | Promise<T>;\n  maxAge?: number;\n  silent?: boolean;\n}\n\n/**\n * Cache an object on the filesystem, given a `name`, `refresh` (can be async),\n * and `maxAge` (defaults to 1hr).\n *\n * Pass `silent: true` to disable logs.\n */\nexport const fromDiskCache = async <T>(\n  {\n    name,\n    poll: refresh,\n    maxAge = 60 * 60,\n    silent = false,\n  }: FromDiskCacheArgs<T>,\n  ...args: any[]\n): Promise<T> => {\n  /**\n   * Initialize a reference to this cache store.\n   */\n  const cacheStore = new CacheStore<T>(name, maxAge, silent);\n  /**\n   * Read a cached version of the value, or write a new one if it doesn't exist\n   * and return that.\n   */\n  try {\n    return await cacheStore.poll(refresh, ...args);\n  } catch (error) {\n    throw new Error(`Error refreshing cache: ${error}`);\n  }\n};"],"names":["fs","join"],"mappings":"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"}